<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sticky Player</title>
<link href="https://fonts.googleapis.com/css2?family=Rancho&family=Poppins:wght@400;700&display=swap" rel="stylesheet"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css">
<style>
:root {
  --play-btn-color: #fff;
  --text-color: #fff;
  --bg-color: #222;
}
body {
  font-family: 'Poppins', Arial, sans-serif;
  margin: 0; /* Ensure no default body margin */
  padding: 0;
  min-height: 100vh; /* For testing sticky player position */
  display: flex;
  flex-direction: column;
}
#sticky-player {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  background: var(--bg-color);
  color: var(--text-color);
  display: flex;
  align-items: center;
  padding: 12px 16px;
  z-index: 1000;
  box-shadow: 0 0 10px #0002;
  transition: top 0.3s, bottom 0.3s;
  font-family: 'Poppins', Arial, sans-serif;
  overflow: hidden; /* Keep this to contain the marquee */
}
#sticky-player.top {
  top: 0;
  bottom: auto;
}
#sticky-player.bottom {
  bottom: 0;
  top: auto;
}

/* New Marquee Wrapper Styles */
#marquee-wrapper {
  flex: 1; /* Allows it to take available space */
  display: flex; /* Helps align song-info */
  flex-direction: column;
  justify-content: center;
  min-width: 0; /* Important for flex items */
  position: relative;
  overflow: hidden; /* This will be the main overflow for the marquee effect */
  white-space: nowrap; /* Keep content on single line */
  height: 3.2em; /* Ensure enough height for both lines (approx. 1.5em for title + 1.2em for artist + gap) */
}

/* Song Info will now just be a container for the individual lines */
#song-info {
  min-width: 0;
  display: flex;
  flex-direction: column;
  gap: 2px;
  position: absolute; /* Position it relative to marquee-wrapper */
  left: 0; /* Will be adjusted by JS, but good default */
  top: 0;
  height: 100%;
  width: 100%; /* Take full width of wrapper */
}

.title-mask, .artist-mask {
  display: block;
  position: relative;
  height: 1.5em; /* Explicit height for consistent mask behavior */
  /* Keep mask-image if you want the fade effect at the end of the line */
  mask-image: linear-gradient(to right, black 80%, transparent 100%);
  -webkit-mask-image: linear-gradient(to right, black 80%, transparent 100%);
}
.artist-mask {
  max-width: none; /* REMOVED fixed max-width for artist-mask to allow full travel */
  height: 1.2em;
  mask-image: linear-gradient(to right, black 80%, transparent 100%); /* Keep if desired */
  -webkit-mask-image: linear-gradient(to right, black 80%, transparent 100%); /* Keep if desired */
}

#song-title, #artist-name {
  font-family: 'Rancho', cursive;
  font-weight: 400;
  font-size: 1.3rem;
  overflow: visible; /* Ensure content is not clipped by self */
  white-space: nowrap;
  letter-spacing: 0.5px;
  line-height: 1.1;
  display: inline-block;
  position: absolute; /* Position the text absolutely within its mask */
  left: 0; /* Start at 0, animation will move it */
  vertical-align: middle;
  transform: translateX(0); /* Reset for animation */
  top: 0; /* Default position for title */
}
#artist-name {
  font-family: 'Poppins', Arial, sans-serif;
  font-size: 0.98em;
  opacity: 0.75;
  letter-spacing: 0.2px;
  top: 1.5em; /* Position artist name directly below title, adjust as needed */
}

#song-title.marquee, #artist-name.marquee {
  will-change: transform;
}

.marquee-copy { /* Style for the duplicated text */
  margin-left: 20px; /* Space between original and copy */
}


#play-stop-btn {
  background: none;
  border: none;
  color: var(--play-btn-color);
  font-size: 2.2rem;
  margin-right: 16px;
  cursor: pointer;
  outline: none;
  display: flex;
  align-items: center;
  flex-shrink: 0; /* Prevent it from shrinking */
}
#play-stop-btn svg {
  width: 3.2rem;
  height: 3.2rem;
  display: block;
}
#toggle-pos-btn {
  background: none;
  border: none;
  color: var(--play-btn-color);
  font-size: 1.7rem;
  margin-left: 16px;
  cursor: pointer;
  outline: none;
  display: flex;
  align-items: center;
  transition: transform 0.2s;
  flex-shrink: 0; /* Prevent it from shrinking */
}
#toggle-arrow {
  opacity: 0.7;
  font-weight: 400;
}
.debug-info {
  position: fixed;
  top: 10px;
  right: 10px;
  background: rgba(0,0,0,0.9);
  color: white;
  padding: 10px;
  border-radius: 5px;
  font-size: 11px;
  max-width: 250px;
  z-index: 1001;
  font-family: monospace;
}
@media (max-width: 600px) {
  #sticky-player { padding: 8px 8px; }
  #play-stop-btn { font-size: 1.5rem; margin-right: 10px; }
  #toggle-pos-btn { font-size: 1.3rem; margin-left: 8px; }
  #song-title { font-size: 1.05rem; }
  #artist-name { font-size: 0.93em; }
  .debug-info { display: none; }
}
</style>
</head>
<body>
<div id="sticky-player" class="bottom">
  <button id="play-stop-btn" aria-label="Play">
    <svg id="play-svg" viewBox="0 0 38 38" fill="none">
      <circle cx="19" cy="19" r="17.5" stroke="currentColor" stroke-width="2"/>
      <polygon points="15,12 28,19 15,26" fill="currentColor"/>
    </svg>
    <svg id="stop-svg" viewBox="0 0 38 38" fill="none" style="display:none;">
      <circle cx="19" cy="19" r="17.5" stroke="currentColor" stroke-width="2"/>
      <rect x="14" y="14" width="10" height="10" fill="currentColor"/>
    </svg>
    <svg id="loading-svg" viewBox="0 0 38 38" fill="none" style="display:none;">
      <circle cx="19" cy="19" r="17.5" stroke="currentColor" stroke-width="2" opacity="0.2"/>
      <circle cx="19" cy="19" r="15" stroke="currentColor" stroke-width="3" stroke-dasharray="25, 20" stroke-linecap="round" fill="none">
        <animateTransform attributeName="transform" type="rotate" from="0 19 19" to="360 19 19" dur="1s" repeatCount="indefinite"/>
      </circle>
    </svg>
  </button>
  <div id="marquee-wrapper"> <div id="song-info">
      <span class="title-mask"><span id="song-title">Loading...</span></span>
      <span class="artist-mask"><span id="artist-name"></span></span>
    </div>
  </div>
  <button id="toggle-pos-btn" aria-label="Toggle position">
    <i class="bi bi-chevron-up" id="toggle-arrow"></i>
  </button>
</div>

<div id="debug-info" class="debug-info" style="display:none;">
  <div><strong>Debug Info</strong></div>
  <div>Updates: <span id="update-count">0</span></div>
  <div>Last: <span id="last-update">-</span></div>
  <div>Status: <span id="api-status">-</span></div>
  <div>Raw: <span id="raw-data">-</span></div>
  <button onclick="debugInfo.style.display='none'" style="margin-top:5px;font-size:10px;">Hide</button>
</div>

<audio id="audio" preload="none"></audio>

<script>
const STREAM_URL = "https://listen.ramashamedia.com:8330/stream";
const SONG_API = "/api/currentsong";

const audio          = document.getElementById("audio");
const playBtn        = document.getElementById("play-stop-btn");
const playSvg        = document.getElementById("play-svg");
const stopSvg        = document.getElementById("stop-svg");
const loadingSvg     = document.getElementById("loading-svg");
const songTitleEl    = document.getElementById("song-title");
const artistNameEl   = document.getElementById("artist-name");
const stickyPlayer   = document.getElementById("sticky-player");
const togglePosBtn   = document.getElementById("toggle-pos-btn");
const toggleArrow    = document.getElementById("toggle-arrow");
const marqueeWrapper = document.getElementById("marquee-wrapper"); // Get the new wrapper

const debugInfo     = document.getElementById("debug-info");
const updateCountEl = document.getElementById("update-count");
const lastUpdateEl  = document.getElementById("last-update");
const apiStatusEl   = document.getElementById("api-status");
const rawDataEl     = document.getElementById("raw-data");

let isPlaying = false;
let updateCount = 0;

async function fetchSongTitle() {
    const resp = await fetch(SONG_API + '?_=' + Date.now());
    if (!resp.ok) throw new Error("Error Loading.");
    const data = await resp.json();

    if (!data.success) {
        throw new Error(data.error || "No Title.");
    }
    return data;
}

async function updateSongInfo() {
    updateCount++;
    updateCountEl.textContent = updateCount;
    lastUpdateEl.textContent = new Date().toLocaleTimeString();
    apiStatusEl.textContent = "Fetching…";

    try {
        const data = await fetchSongTitle();

        apiStatusEl.textContent = "Success";
        rawDataEl.textContent = (data.raw || '').substring(0, 30) + "…";

        // Store original text before duplication
        songTitleEl.dataset.originalText = data.title || "No track information";
        artistNameEl.dataset.originalText = data.artist || "Ramasha Media";

        // Set text content
        songTitleEl.textContent = songTitleEl.dataset.originalText;
        artistNameEl.textContent = artistNameEl.dataset.originalText;

        applyMarquee();
    } catch (err) {
        songTitleEl.textContent = err.message === "No Title." ? "No Title." : "Error Loading.";
        artistNameEl.textContent = "";
        apiStatusEl.textContent = "Failed: " + err.message;

        // Reset marquee for both elements on error
        resetMarquee(songTitleEl);
        resetMarquee(artistNameEl);
    }
}

function resetMarquee(element) {
    element.classList.remove("marquee");
    element.style.animation = "";
    // Restore original text content if it was duplicated
    if (element.dataset.originalText) {
        element.textContent = element.dataset.originalText;
    }
}

function applyMarquee() {
    // Reset any existing marquee animations and restore original text
    resetMarquee(songTitleEl);
    resetMarquee(artistNameEl);

    // Remove old dynamic styles
    const oldStyle = document.getElementById("dynamic-marquee-keyframes");
    if (oldStyle) oldStyle.remove();

    // Wait one frame for layout to settle and get accurate dimensions
    requestAnimationFrame(() => {
        const stickyPlayerRect = stickyPlayer.getBoundingClientRect();
        const marqueeWrapperRect = marqueeWrapper.getBoundingClientRect();
        
        let keyframesCSS = '';
        const speed = 40; // Pixels per second, adjust as desired

        // --- Title Marquee ---
        const originalTitleWidth = songTitleEl.scrollWidth;
        
        // Check if the title overflows the actual space available for it within the player.
        // We compare against the marqueeWrapper's width as it defines the visible area.
        if (originalTitleWidth > marqueeWrapperRect.width) {
            // Duplicate the content for seamless loop
            songTitleEl.innerHTML = songTitleEl.textContent + '&nbsp;&nbsp;<span class="marquee-copy">' + songTitleEl.textContent + '</span>';

            // Calculate starting position (right edge of sticky player)
            // The `from` translateX value should bring the left edge of the content
            // to the right edge of the *sticky player's marquee-wrapper area*.
            // We need the offset of the songTitleEl relative to the marqueeWrapper's left edge
            const songTitleLeftOffset = songTitleEl.getBoundingClientRect().left - marqueeWrapperRect.left;
            
            // Start from the right edge of the marqueeWrapper
            const startX = marqueeWrapperRect.width - songTitleLeftOffset;
            
            // Calculate ending position (left edge of first instance goes off the left of marquee-wrapper)
            // This is the negative of the original content width plus its offset relative to marqueeWrapper's left edge
            // Plus a little extra for full clear + space between copies
            const endX = - (originalTitleWidth + songTitleLeftOffset + 20); 

            const totalTravelDistance = Math.abs(startX - endX); // Use absolute difference for distance
            const titleDuration = totalTravelDistance / speed;

            keyframesCSS += `
            @keyframes title-marquee {
                0% { transform: translateX(${startX}px); }
                100% { transform: translateX(${endX}px); }
            }`;

            // Apply title animation
            songTitleEl.classList.add("marquee");
            songTitleEl.style.animation = `title-marquee ${titleDuration}s linear infinite`;
        }


        // --- Artist Marquee ---
        const originalArtistWidth = artistNameEl.scrollWidth;
        // Check if artist overflows the marqueeWrapper's width
        if (originalArtistWidth > marqueeWrapperRect.width) { 
            // Duplicate the content for seamless loop
            artistNameEl.innerHTML = artistNameEl.textContent + '&nbsp;&nbsp;<span class="marquee-copy">' + artistNameEl.textContent + '</span>';

            const artistNameLeftOffset = artistNameEl.getBoundingClientRect().left - marqueeWrapperRect.left;
            
            const startX = marqueeWrapperRect.width - artistNameLeftOffset;
            const endX = - (originalArtistWidth + artistNameLeftOffset + 20); // Add a little extra

            const totalTravelDistance = Math.abs(startX - endX);
            const artistDuration = totalTravelDistance / speed;

            keyframesCSS += `
            @keyframes artist-marquee {
                0% { transform: translateX(${startX}px); }
                100% { transform: translateX(${endX}px); }
            }`;

            // Apply artist animation
            artistNameEl.classList.add("marquee");
            artistNameEl.style.animation = `artist-marquee ${artistDuration}s linear infinite`;
        }

        // Apply animations if we have keyframes
        if (keyframesCSS) {
            const style = document.createElement("style");
            style.id = "dynamic-marquee-keyframes";
            style.textContent = keyframesCSS;
            document.head.appendChild(style);
        }
    });
}


playBtn.addEventListener("click", async () => {
    if (isPlaying) {
        audio.pause();
        audio.src = "";
        isPlaying = false;
        playSvg.style.display = "block";
        stopSvg.style.display = "none";
        loadingSvg.style.display = "none";
    } else {
        try {
            playSvg.style.display = "none";
            stopSvg.style.display = "none";
            loadingSvg.style.display = "block";

            audio.src = STREAM_URL;
            await audio.play();

            isPlaying = true;
            loadingSvg.style.display = "none";
            stopSvg.style.display = "block";

            updateSongInfo();
        } catch (e) {
            isPlaying = false;
            loadingSvg.style.display = "none";
            playSvg.style.display = "block";
            stopSvg.style.display = "none";
            alert("Unable to play stream: " + e.message);
        }
    }
});

audio.addEventListener("play", updateSongInfo);
audio.addEventListener("ended", () => {
    isPlaying = false;
    playSvg.style.display = "block";
    stopSvg.style.display = "none";
    loadingSvg.style.display = "none";
});
audio.addEventListener("pause", () => {
    if (audio.ended || audio.error) {
        isPlaying = false;
        playSvg.style.display = "block";
        stopSvg.style.display = "none";
        loadingSvg.style.display = "none";
    }
});
audio.addEventListener("error", () => {
    isPlaying = false;
    playSvg.style.display = "block";
    stopSvg.style.display = "none";
    loadingSvg.style.display = "none";
});

togglePosBtn.addEventListener("click", () => {
    const isBottom = stickyPlayer.classList.toggle("bottom");
    stickyPlayer.classList.toggle("top", !isBottom);

    toggleArrow.classList.toggle("bi-chevron-up", isBottom);
    toggleArrow.classList.toggle("bi-chevron-down", !isBottom);

    // Reapply marquee after position change
    setTimeout(applyMarquee, 100);
});

let clickCount = 0;
document.addEventListener("click", () => {
    clickCount++;
    setTimeout(() => (clickCount = 0), 500);
    if (clickCount === 3) {
        debugInfo.style.display = debugInfo.style.display === "none" ? "block" : "none";
    }
});

// Reapply marquee on window resize
window.addEventListener('resize', () => {
    setTimeout(applyMarquee, 100);
});

updateSongInfo();
setInterval(updateSongInfo, 10000);
</script>
</body>
</html>